
% --------------------------------------------------------------------


\section{Introduction}
\begin{sloppypar}
    In recent years, mobile applications and web services which cater to them 
    have revolutionized our daily lives by infiltrating social life, shopping 
    and almost every aspect of our existence. The rapid expansion and, at times, 
    even faster decline of these web services needs a matching architecture to 
    meet their very specific needs.  
\end{sloppypar}
\begin{sloppypar}
    There are many web services already in use which were designed and 
    implemented before the onslaught of microservices. Some of these services 
    have already made the switch such as Netflix but this is not the case for 
    the whole industry. Also, when a new service is being created the business 
    domain might not be established yet. Additionally there might exist a fair 
    amount of uncertainty in what exactly is to be developed. This is 
    furthermore amplified by using agile software development methods in which
    the change in requirements is welcome even in later stages of the 
    development \citep{agilemanifesto}.
\end{sloppypar}
\begin{sloppypar}
    When new development is carried out by a startup, the initial architecture 
    might still be a monolith one. \citet{newman2019} states that, due to limited 
    resources, a monolith might be a better fit to these companies trying to 
    navigate to the actual product they are to offer. In the case of success, 
    the need to rapidly scale the offering emerges. \citet{newman2019} refers 
    to these companies as "scale-ups". \citet{newman2019} also states that it 
    is much easier to refactor an existing service than to create a new one and
    thus the need to split monoliths to microservices is and probably will be 
    relevant to the near future.
\end{sloppypar}
\begin{sloppypar}
    \citet{10.1007/978-3-319-74433-9_3} finds that as the codebase becomes large 
    the Monolith Architecture (MA) leads to slower development. This is due to 
    the possible complexity inherint in the entwined monolith. The amount of 
    code to refactor is much larger than in a small microservice. Microservice 
    should do one thing and, as such, it should be more understandable.
\end{sloppypar} 
\begin{sloppypar}
    The Stack Overflow annual survey \citep{sosurvey2019} conducted on 
    developers found that half of the respondents identified as full-stack or 
    backend developers. 40\% of the respondents had less than five years of 
    professional experience.
\end{sloppypar}
\begin{sloppypar}
    New developers entering the workforce have a very different mindset than 
    the older more seasoned professionals. Thus, it is very clear that the ways 
    of working and paradigms to be used are constantly changing.
\end{sloppypar}
\begin{sloppypar}
     Microservices are not the proper choice for all web services 
     \citep{newman2019}. Microservices offer multiple benefits such as easier 
     scalability and more modular structure for the application. When the 
     architecture needs to be changed, the process needs to happen in an orderly 
     and safe way. Often overlooked security aspects need to be identified and 
     addressed as early as possible.
\end{sloppypar}
\begin{sloppypar}
    Microservice Architecture (MSA) differs in many ways from 
    the more traditional Monolithic Architecture (MA). This shift entails very 
    specific security issues.
\end{sloppypar}
\begin{sloppypar}
    In this thesis, the MSA and related security literature is surveyed and the 
    main differences between MA and MSA on security aspects are discussed. 
\end{sloppypar}
\begin{sloppypar}
    The first chapter discusses the \dots
    The last chapter in the thesis contains the conclusions and presents further 
    research topics.
\end{sloppypar}


% --------------------------------------------------------------------


\section{Architectural Comparison}
\begin{figure}[h]
    \includegraphics[scale=0.75]{{monolith_architectur.png}}
    \centering
    \caption{Traditional Monolithic Architecture \citep{10.1007/978-3-319-74433-9_3}}
    \label{fig:monolith}
\end{figure}
\begin{sloppypar}
    MA can be visually presented as in figure \ref{fig:monolith}. The web 
    service is a layered structure in which all of the different layers have a 
    specific task to perform. This follows the Model-View-Controller design 
    pattern \citep{trygvemvc}. The UI is the View, the business logic is the 
    Controller, and the database is the Model.
\end{sloppypar}
\begin{figure}[h]
    \includegraphics[scale=0.75]{{MSA.png}}
    \centering
    \caption{Microservice Architecture \citep{10.1007/978-3-319-74433-9_3}}
    \label{fig:microservice}
\end{figure}
\begin{sloppypar}
    The MSA presented in figure \ref{fig:microservice} has many problem 
    areas of which one is the challenging security implementation. 
    This is due to the fact that every microservice accessible to the client 
    can also be accessed or contacted by other more malicious parties in the 
    same network. The network in the case of web services is the internet. The 
    attack surface available for the malicious party is the entirety of the 
    APIs offered by the microservices.
\end{sloppypar}
\begin{sloppypar}    
    One solution to limit the attack surface is the addition of API Gateway to 
    the architecture as in figure \ref{fig:microserviceapigateway}. 
    \citet{DBLP:journals/corr/MontesiW16} present an API Gateway design pattern. 
    In this pattern, there exists only one web service accessible to clients. 
    The API Gateway allows for a natural place for a Policy Enforcement Point 
    (PEP) and other more MSA specific features such as service discovery. The 
    security features can be implemented in the API Gateway making it a 
    critical component. Since all communication is to either flow through or be 
    sanctioned by the API Gateway the performance and accessability are critical.
\end{sloppypar}
\begin{figure}[h]
    \includegraphics[scale=0.75]{{MSA_API_GATEWAY.png}}
    \centering
    \caption{Microservice Architecture With API Gateway \citep{oidcflow}}
    \label{fig:microserviceapigateway}
\end{figure}


% --------------------------------------------------------------------


\section{Changing the architecture}
\begin{sloppypar}
    The changing of the architecture of an already deployed service from MA to MSA 
    should be a gradual process. This ensures a smooth transition and minimizes 
    outages to the customers. Sometimes, though this is not possible. 
    \citet{newman2019} states that when a monolithic application is 
    implemented following a desing patterns such as the MVC \citep{trygvemvc} 
    this can lead to difficulties in the refactoring. The codebase is not split 
    according to the business domain but follows a rigid design pattern.
\end{sloppypar}
\begin{sloppypar}
    In order for the process to be as simple as possible, the MA is or at least 
    should be split into modules with separation of concerns \citep{secchalmsa}. 
    The actual splitting of the monolith can be carried out in various ways, 
    one of which is Domain Driven Design \citep{newman2019}.
\end{sloppypar}
\begin{sloppypar}
    The MSA differs from a MA in fundamental ways. According to 
    \citet{fowlerlewisms}, one main difference is the communication between 
    the components. In a monolith application the processes can send function 
    calls or method invocations amongst themselves. In MSA, the messaging is 
    based on sending messages or HTTP requests. Function calls entail a 
    stackframe creation in the call stack, execution of the function code, and 
    finally popping the stackframe and returning the result. Compilers can 
    optimize the code further and inline the function calls to eliminate the 
    stackframe creation and the following procedures.
\end{sloppypar}
\begin{sloppypar}    
    Communication using the network is extremely slow compared to local 
    function calls. \citet{webdelays} studied the response times of web sites 
    offered to the public. The websites response times where measured in 
    seconds. The requests sent to other microservices through the network are 
    much slower than function calls within one computer. Therefore, the 
    communication patterns should be changed to take into account the change in 
    communication path. If the architecture is changed in such a way that the 
    previous communication model amongst the components is preserved, there 
    would be an excessive amount of communication and the resulting system 
    would not be as performant \citep{fowlerlewisms}.
\end{sloppypar}


% --------------------------------------------------------------------


\section{Security}
\begin{sloppypar}
    \citet{closer18} implemented a test system mimicking the Deutsche Bahn 
    seat reservation system using MSA. The purpose of the test system was to
    analyze security risks that were introduced by the implementation. In the 
    study they categorized the solution to three layers: first of which was the 
    compute provider, the second was the encapsulation tehcnology, and the 
    third one was the deployment. The technologies for these layers were: 
    Amazon Web services, Docker for containers, and Kubernetes (k8s) nodes, 
    respectively. They found out that the cloud-based infrastructure when used 
    in MSA resulted in a more complex solution than in MA. The added layers 
    such as the K8s, have to be configured correctly and an error in one could 
    potentially compromise the whole system. In addiniton, implementation of 
    security is very difficult and resource intensive. The rewards from a good 
    security are invisible. When microservices are implemented or even planned 
    the security should be taken into account as early as possible. 
    Implementing security later in the project or as an after thought can be 
    more expensive and very difficult.
\end{sloppypar}
\begin{sloppypar}
    Implementing security is hard. A theoretical proof for this can be found in 
    \citet{andersson2001information}. His main finding was that an attacker has 
    an advantage over the developers trying to defend a system. For the system 
    to be secure the defending developers have to find all of the bugs where as 
    the attacker has to find only one.
\end{sloppypar}


% --------------------------------------------------------------------


\section{Authentication and Authorization}
\begin{sloppypar}
    In the cases where the user has to be authenticated, the web service needs 
    a way to do this securily. Usually authentication is done using a tuple 
    containing user credentials i.e. a username and a password for the user. The
    user is authenticated and a key or token is transmitted to the user via the 
    network. This communication in both MA and MSA, should be encrypted in a way 
    that none of the actors in the transfer path can intercept the message and 
    misuse the credentials.
\end{sloppypar}
\begin{sloppypar}
    The credential counterparts i.e. the secret shared by the server and the 
    user have to be available for the web service for verification. When using 
    MSA, the service should own it's own data. When ever information is 
    available it is a target for thieves and hackers. The services in MSA are 
    to be individually deployable and the service scalable. Authentication 
    service implementation has to take this into account. The service has to 
    adhere to practices that minimize the risks of data breaches. 
\end{sloppypar}
\begin{sloppypar}
    As has been mentioned previously implementing security is hard and resource 
    intensive. Therefore, the authentication implementation should adhere to an 
    already existing framework or an another entity providing the 
    authentication. This is the case for both the MA and MSA. The available 
    choices include Lightweight Directory Access Protocol (LDAP), OpenID 
    Connect (OIDC), Security Assertion Markup Language (SAML), and Kerberos.
\end{sloppypar}

\subsection{Authentication and Authorization in MA}
\begin{sloppypar}
    In MA, it is possible to implement features in such ways that a session can 
    carry user information. This information can consist of the granted roles 
    and rights for the user. This session can be queried when access control is 
    needed to execute an action or operation or a specific authorization 
    service or module can exist. An example of an web service implemented in MA 
    is presented in figure \ref{fig:MA_AUTH}. The user accessing the web service
    sends a request to load balancer which has all the information on the 
    currently operational services. Each of the services is a single process in 
    which an authentication and authentication service are present. When a user 
    is first accessing the service credentials are to be verified and in a 
    succesful case a session is created for the process. 
\end{sloppypar}
\begin{figure}[h]
    \includegraphics[scale=0.70]{{MA_AUTH.png}}
    \centering
    \caption{Traditional load balanced MA web service \citep{authinmsa}}
    \label{fig:MA_AUTH}
\end{figure}

% --------------------------------------------------------------------
\begin{sloppypar}
    Authorization of the user rights can be implemented in various ways. One of 
    which is an authorization service which can contain the access control 
    matrix. Services being accessed verify from the authorization service that 
    the client user or the role that the user has can access the requested 
    service or functionality. In MA, the access rights to functionality can 
    be implemented using annotations within the source code. The authorization 
    is verified in memory and without any communication over the network. 
\end{sloppypar}
\begin{sloppypar}
    In MSA accessing the access control matrix or matrices is not as easy as it 
    is in MA. In order to verify that a specific right exists, the service would 
    have communication with the authorization service. This communication would 
    need to happen every time a user tries to access a functionality with 
    access restrictions. This could potentially lead to extremely lively 
    communication from all the services forming a bottleneck at to the 
    authorization service. An example of such architecture is presented in 
    figure \ref{fig:MSA_AUTH_SERVICE}.
\end{sloppypar}
\begin{figure}[h]
    \includegraphics[scale=0.75]{{MSA_AUTH_SERVICE.png}}
    \centering
    \caption{MSA authorization service \citep{authinmsa}}
    \label{fig:MSA_AUTH_SERVICE}
\end{figure}




\subsection{OIDC}
\begin{sloppypar}
    OIDC is an identity layer to accompany OAuth 2.0 authorization framework 
    based protocol. 
\end{sloppypar}
\begin{figure}[h]
    \includegraphics[scale=0.75]{{OIDC_FLOW.png}}
    \centering
    \caption{OIDC steps}
    \label{fig:oidcflow}
\end{figure}
\begin{sloppypar}
    An example of an OIDC flow is presented in figure \ref{fig:oidcflow}. The 
    process flow steps are: the client application requests an authentication 
    from the identity provider, the end user is authenticated and authorization 
    is obtained, the indetity provider responds to the initial authentication 
    request by sending ID token and a possible access token, the client 
    application can request the end user claims from the authorization server 
    with the access token, and finally the authorization service returns the 
    claims to the client application. 
\end{sloppypar}

% \section{Authorization}








% \begin{sloppypar}
%     https://techbeacon.com/security/microservices-apps-do-identity-access-management-without-overhead
% \end{sloppypar}


% \begin{sloppypar}
%     token (JWT, OAuth 2.0), (API gateway, IdP) vs distribution 
% \end{sloppypar}
% \begin{sloppypar}
%     Identity and Access Management (IAM),
%     Identity federation, Azure Active Directory, Active Directory Federation Services (ADFS),
%     Google, Facebook, Twitter, LinkedIn etc.,
%     Single-Sign-On (SSO), Security Assertion Markup Language (SAML),
%     SAML identity provider, OpenId provider, OAuth 2.0,
%     OpenId Connect (OIDC),
%     Identity Management: Identification, Authentication, Authorization.
%     \dots
% \end{sloppypar}

\subsection{Java Script Object Notation Web Token (JWT)}
\begin{sloppypar}
    JWT is a format to represent claims. It is base64 encoded, point separated 
    strings, which can easily be carried in the HTTP request or response. The 
    contents is key value pairs, and the token may or may not be signed and 
    encrypted \citep{RFC7519}. The token may contain an expiration time. If the 
    token is used to validate requests without a server side implementation 
    that can revoke a token, it will be valid until this time. The JWT token is 
    issued by an authority trusted by the service. In figure 
    \ref{fig:TOKEN_AUTH} a basic bearer token based authentication and 
    authorization is depicted. A client initially enters credentials to a login 
    page and the authorization service issues a token for the user. This token
    is used in place of the credentials to access restricted resources.
\end{sloppypar}
\begin{figure}[h]
    \includegraphics[scale=0.75]{{TOKEN_AUTH.png}}
    \centering
    \caption{Bearer token based authentication \citep{authinmsa}}
    \label{fig:TOKEN_AUTH}
\end{figure}
\begin{sloppypar}
    The signing of JWT can be carried out in various ways. These are presented 
    in the \citet{RFC7515}. The signature is computed using the algorithm and 
    keys or certificates specified in the header values. When the token is 
    signed using a private key it can be verified by all parties in 
    possession of the public key. 
\end{sloppypar}


\subsubsection{Known Vulnerabilities}
\begin{sloppypar}
    The choices for the algorithm for signing the JWT algorithm contain 
    "none" as one of the choices. This was found to be troublesome by 
    \citet{nonejwt}. He found that many libraries did not operate in the 
    desired way. The receiving party could be fooled to validate a mutated 
    token without any signature with the "none" as it's algorithm. In 
    addition to this vulnerability \citet{nonejwt} found that the verification 
    suffered from another fatal flaw. When a token was created by using a 
    symmetric algorithm, the servers could be fooled in to believing that a 
    token signed by just the public key and not the secret HMAC key was a valid 
    one.
\end{sloppypar}

\subsection{Opaque Token}
\begin{sloppypar}
    \citet{authinmsa} compared several authentication and authorization 
    solutions. One of the solutions discussed in the paper was the usage of an 
    opaque access token for the client and API Gateway communication and map 
    an Opaque token to JWT in the API Gateway. This would be used in all other 
    communication as the means to autenticate and authorize the user. The main 
    problem the opaque token is said to solve is the logout problem. A bearer 
    token is valid until expiration and the client can not invalidate the 
    token. The opaque token flow is presented in figure 
    \ref{fig:OPAQUE_TOKEN_API_GATEWAY}.
\end{sloppypar}
\begin{sloppypar}
    The use of two tokens has many advantages. The token granted to the client 
    allows access only to the API Gateway. This token can not be used to access 
    the services directly. Furthermore, the opaque token be can revoked by 
    simply removing it from the storage for the token pairs. The usage of an 
    internal JWT can alleviate some of the issues when MA is to be changed to 
    MSA. Though not advisable, the JWT can carry session information and the 
    whole session. This allows for more of the previous MA implementation to be 
    used without as many changes.
\end{sloppypar}
\begin{figure}[h]
    \includegraphics[scale=0.75]{{OPAQUE_TOKEN_API_GATEWAY.png}}
    \centering
    \caption{API Gateway and opaque token \citep{authinmsa}}
    \label{fig:OPAQUE_TOKEN_API_GATEWAY}
\end{figure}

% \subsection{Attacks}
% \begin{sloppypar}
%     Authentication can be attacked by a multitude of methods.     
%     \begin{itemize}
%         \item Cracking
%         \item Impersonation attacks
%         \item Hacking the system
%         \item Malware
%         \item Social engineering
%         \item Cracking the encryption on the communication channel exchanging 
%         credentials and keys or tokens.
%     \end{itemize}
% \end{sloppypar}
% \begin{sloppypar}
%     From 2013 onwards malware and data breaches performed by hackers have 
%     increased. The motivation to steal user data for hackers is the value of 
%     them in the black market. The damage of a data breach to the service 
%     provider can be substantial. For example the Yahoo data breach damages have 
%     been estimated to have reached \$440 billion. The attacks in general have 
%     been targeted to entities with valuable data and insufficient security 
%     infrastructure. The least likely target to be hacked where non profit 
%     organisations and the most likely were medical related organizations 
%     \citep{breach}. The hacked account credentials have to some extent been 
%     available for download from the web. \citet{pwned} created a service where 
%     everyone can verify whether any of their accounts are amongst the ones added 
%     to the service. The service named as ”’;– have i been pwned ?” allows users 
%     to enter their username or password to the site and see a result.
% \end{sloppypar}

% \subsection{Authentication in Monolith}
% \begin{sloppypar}
%     Discussion on various ways to execute authentication in MA. 
% \end{sloppypar}

% \subsubsection{Authentication in Microservice Architecture}
% \begin{sloppypar}
% \end{sloppypar}


% -----------------------------------------------------------------------------




% \subsection{Authorization in Microservice Architecture}
% % --------------------------------------------------------------------
% \section{Session}
% \subsection{Session in Monolith}
% \subsection{Session in Microservice Architecture}
% % --------------------------------------------------------------------
% \section{Cloud}
% \subsection{Monolith}
% \subsection{Microservices Architecture}
% % --------------------------------------------------------------------
% \section{Monitoring}
% \subsection{Monolith}
% \subsection{Microservices Architecture}
% % --------------------------------------------------------------------
% \section{Logging}
% \subsection{Monolith}
% \subsection{Microservices Architecture}
% % --------------------------------------------------------------------
% \section{Fault Tolerance}
% \subsection{Monolith}
% \subsection{Microservices Architecture}


% --------------------------------------------------------------------

\section{Communication}
\begin{sloppypar}
    As already explained, in MA, the service components can communicate using 
    events, procedure calls or other methods available within a single server 
    machine. Usually all this communication stays within a single computer and 
    thus does not easily compromise confidentiality.
\end{sloppypar}
\begin{sloppypar}
    
\end{sloppypar}


% \begin{sloppypar}
%     Microservices can not trust any of the \citep{otterstad}
% \end{sloppypar}


% \begin{sloppypar}
%     In MSA single services communicate via a network.
%     TODO

%     Next messaging systems list is from \citep{secchalmsa}:
% lightweight
% -
%     REST API, Sync RPC,GraphQl
%     -
%     Async REST, gRPC
%     - 
%     Apache Kafka, ZeroMQ
%     -
%     Java Message Service: ActiveMQ, JBOSS messaging, Glassfish
%     -
%     AMQP: RabbitMQ, Qpid, HornetQ
%     -
%     MuleESB, Apache ServiceMix, JBossESB
% -
% heavyweight
%     WebSocket
% \end{sloppypar}

\subsection{Representational State Transfer (REST)}
\begin{sloppypar}
    \citet{restroy} presented REST in 2000. REST has become a very successful 
    architectural style. The style was derived using various constraints, one 
    of which is stateless communication. This entails that a request must 
    contain all the information needed to fulfill the request because the 
    server does not keep track of the client. All session state is stored in 
    the client, of which the server has no prior knowledge before a request. In 
    her doctoral thesis, \citet{secchalmsa} critiques the REST paradigm from 
    the security perspective. She states that the design of the architecture 
    does not meet the security requirements for web applications. She also 
    states that REST does not allow for any server side sessions and thus token 
    revocation is impossible. Tokens can be validated only for the correct 
    issuer by signature and for expiration. As such tokens are more compatible 
    with REST, but there still has to be the public keys in the server for signature 
    verification.
\end{sloppypar}

% \subsection{Event-Driven Communication}
% \begin{sloppypar}
% \end{sloppypar}

\subsection{Coping With Failure in Communication}
\begin{sloppypar}
    \citet{DBLP:journals/corr/MontesiW16} present widely used design pattern for MSA.
    The Circuit Breaker can be used to mitigate the very likely case that a 
    microservice operates slower than the other services calling it and 
    runs out ot resources to fulfill the requests in time. The circuit breaker
    is either implemented in the microservice or as a proxy between the client 
    and the microservice. When the microservice does not service requests as 
    intended, the circuit breaker trips and sends a failure message to the 
    clients immediately when requests are received, thus allowing the 
    microservice time to service the prior requests.
\end{sloppypar}
\begin{sloppypar}
    The circuit breakers can prevent an application from becoming completely 
    unresponsive and crashing when a denial of service attack is carried out on 
    the service.
\end{sloppypar}

% --------------------------------------------------------------------
% \section{Defence in depth}
% \begin{sloppypar}
%     \citet{defdepau} propose a solution for secure communication in MSA even in multicloud solutions.
%     perimeter defence -> neglect security of individual microservices.
% \end{sloppypar}
% \begin{sloppypar}
% \end{sloppypar}
% \begin{sloppypar}
% \end{sloppypar}
% \section{Random rambling}
% \begin{sloppypar}
%     This paper could be about authorization and the switch from MA to MSA.
%     The authorization can be designed and implemented in so many ways that
%     the paper should probably be narrowed down even further.
% \end{sloppypar}
% \begin{sloppypar}
%     Sessions can be used in MSA when the architecture has an API Gateway. The 
%     session is stored in the Gateway and a session key (?) is carried in the 
%     requests made by the client application. The API Gateway then verifies the
%     request and can grant access to specific service. Without the Gateway the
%     session would have to be either centrally maintained at a session service 
%     or be handeld by the client and passed along in the requests.
% \end{sloppypar}
% \begin{sloppypar}
%     Client handled session is easy to tamper with and has risks involved. The 
%     service would either have to trust the client offered session or verify a 
%     signature. In both of these cases the client application would have to be 
%     aware of the service and would be able to communicate with it directly. 
%     This would bring considerable overhead on all the services and a security 
%     risk.
% \end{sloppypar}
% \section{Comments}
% \begin{sloppypar}
%     authentication, 
%     credential
% \end{sloppypar}
% \begin{sloppypar}
%     authorization, 
%     access control, 
%     policy decision point (PDP), 
%     policy enforcement point (PEP), 
%     A Framework for Policy-based Admission Control https://tools.ietf.org/html/rfc2753
% \end{sloppypar}
% --------------------------------------------------------------------
% \section{Definitions}
% \begin{sloppypar}
%     This thesis uses the following definitions.
% \end{sloppypar}

% \subsection{Microservice}
% \begin{sloppypar}
%     MSA can be viewed as an extension of the service oriented 
%     architecture (SOA)\citep{newman2019,fowlerlewisms}. It's guiding principles are stated in the SOA manifesto 
%     \citep{soamanifesto} and one is to prioritize:
%     \begin{quotation}
%         \noindent \it
%         \begin{itemize}
%             \item Business value over technical strategy
%             \item Strategic goals over project-specific benefits 
%             \item Intrinsic interoperability over custom integration 
%             \item Shared services over specific-purpose implementations 
%             \item Flexibility over optimization 
%             \item Evolutionary refinement over pursuit of initial perfection
%         \end{itemize}
%     \end{quotation}
% \end{sloppypar}
% \begin{sloppypar}
%     A microservice is a service that: is independently deployable,
%     is modeled around business domain,
%     that owns the data that they need to operate,
%     that communicates via network,
%     is technology agnostic,
%     that encapsulates data storage and retrieval and 
%     that has stable interface \citep{newman2019}.
% \end{sloppypar}

% \subsection{Security}
% \begin{sloppypar}
%     Security can be defined in multiple ways but in this thesis security 
%     and more specifically information security is defined as consisting of 
%     Confidentiality, Integrity, and Availability (CIA) as is stated in the 
%     pocket book on ISO/IEC 27001 -standard for information security \citep{isoiec27001}.
% \end{sloppypar}
% \begin{sloppypar}
%     The ISO/IEC 27001 standard defines confidentiality as such that information 
%     or property is available to the authorized user only. The authorized users 
%     can consist of persons, processes or entities to whom the information or 
%     property can be disclosed. Integrity means that the data or property is 
%     safeguarded for accuracy and completeness. Availability in this web service
%     context is defined as such that the property or information is available 
%     when it is needed.
% \end{sloppypar}
% --------------------------------------------------------------------
%\section{Confidentiality}
%\begin{sloppypar}
%     Confidentiality in a web service is usually critical security feature. 
%     There are specific services which do not nead information confidentiality 
%     regarding some of the data such as public weather services and other similar data.
%     Some of the information is still regarded sensitive and must be kept confidential. 
%     These data can consists of personal, user, logs or other similar content.
%     Users should not be able to use or view content not authorized to him/her. 
%     To verify this a form of access control has to be performed. Access control 
%     consists of user authentication and authorization. A user has to 
%     authenticate him/her self and authorization is acquired to access to 
%     information or property.
% \end{sloppypar}
% \begin{sloppypar}
%     In an MA access control can be implemented using sessions. 
%     A user authenticates using appropriate channels and a session with a session key is created. 
%     The session can have an expiration time and the messages originating from 
%     the user interface (UI) carry this key. Sessions and session keys can be used 
%     in a distributed system which MSA is but the implementation is more difficult \citep{authinmsa}.
% \end{sloppypar}
% --------------------------------------------------------------------
% \section{Integrity}
% \begin{sloppypar}
%     Information integrity in an MA web service is usually left to a single database 
%     and sound architectural choices (REALLY? SOURCE).
%     Transactions can be used when updating database constents to make sure that
%     atomicity, consistency, isolation, and durability (ACID) \citep{acid} is followed.
%     When using MSA according to the definition each of the micro services should contain 
%     or have access to it's own data i.e. database. This leads to extreme difficulties in information integrity.
%     TODO
% \end{sloppypar}
% --------------------------------------------------------------------
% \section{Availability}
% \begin{sloppypar}
%     Availability in this web service context is defined as such that the property or information 
%     is available when it is needed.
% \end{sloppypar}

% \subsection{Possible Attacks}
% \begin{sloppypar}
%     D-o-S 
% \end{sloppypar}
% --------------------------------------------------------------------


\section{Other MSA specific security matters}
% \begin{sloppypar}

% \end{sloppypar}

% \subsection{Platforms}
% \begin{sloppypar}
%     Docker Swarm, Kubernetes (K8s), Azure, sandbox, virtualization 
% \end{sloppypar}

% \subsection{Monitoring and logging}
% \begin{sloppypar}
% \end{sloppypar}
% \subsection{Software Development}
% \begin{sloppypar}
% \end{sloppypar}
% \subsection{Software Development}
\begin{sloppypar}
    When software is developed using MA, it is usually deployed as a whole and 
    the program code can be compiled, tested and used as a single unit or 
    multiple modules. In contrast, a service implemented in MSA 
    can be deployed in single microservice units, and thus each component can 
    be worked upon individually and deployed once ready. 
\end{sloppypar}
\begin{sloppypar}
    The immediacy in the deployment of the microservices entails a very specific 
    security risk. \citet{integinside} present threats from malicious insiders 
    working on the services as developers or other positions with access to 
    sensitive information. In microservice development, the finished 
    implementations are to be immediately released to production. There are 
    steps in the CD pipeline prior to this but once tests pass in the test 
    environments the pipeline is supposed to publish the changes to the actual 
    production environment. The paper presents four specific threats. The first 
    one is that the knowledge of sensitive information is spread among the 
    developers more widely than in MA. This is due to access needs by 
    developers. The second threat is that the insiders monitoring and operating 
    the running system intentionally harm the system by making malicious 
    changes. The third threat is the developers knowing the configurations and 
    their ability to make almost instantaneous changes to them or the 
    microservices themselves. The last presented threat in the paper is the 
    non-repudiation. The system is not able to disallow malicious requests when 
    the developers have had access to the keys and other configurations. They 
    can effectively implement services or requests that emit malicious requests 
    or responds. Malicious attempts in a MA are more easily screened by 
    performing security audits and by peer reviewing the code. In a MSA the 
    knowledge of a single service and it’s inner workings are shared by a more 
    limited number of people. Finding the compromised actions from the 
    interoperability of the distinct microservices is a daunting task.
\end{sloppypar}
\begin{sloppypar}
    Malicious attempts in a MA are more easily screened by performing security
    audits and by peer reviewing the code. In a MSA the knowledge of a single 
    service and it's inner workings are shared by a more limited number of people.
    Finding the compromised actions from the interoperability of the distinct 
    microservices is a daunting task.
\end{sloppypar}

\subsection{Service discovery}
\begin{sloppypar}
    Service discovery as presented in \citet{DBLP:journals/corr/MontesiW16} is a 
    design pattern in which a registry is kept on currently running microservices. 
    The microservices register them selves to the service discovery registry. 
    This registry is used by either a router to route client service calls to 
    running microservices or by the client directly.
\end{sloppypar}

% \begin{sloppypar}
% \end{sloppypar}
% \begin{sloppypar}
%     https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/
%     https://www.consul.io
% \end{sloppypar}


\subsection{Externalized configuration}
\begin{sloppypar}
    To allow for easy configuration change management there should exist a 
    configuration orchestration service. This service should have an API from 
    which services in their startup can load their appropriate configuration. 
    The configuration of the whole system can be easily maintained through the 
    API.
\end{sloppypar}
\begin{sloppypar}
    The contents of the configuration is highly sensitive information. It 
    consists of addressess, credentials and other information that alter 
    the behaviour of the system. Therefore, the content must be stored safely 
    and not allowed to be read or altered by unauthorized users.
\end{sloppypar}




% --------------------------------------------------------------------
% --------------------------------------------------------------------

\section{Conclusion}
\begin{sloppypar}
    This paper discussed the security aspects of changing the architecture from MA to MSA.
\end{sloppypar}
% \begin{sloppypar}
%     In MSA there are more things to go wrong than in MA. The deployment 
%     necessitates installing, virtualization, monitoring, and a plethora of other
%     tools. In some cases, these tools might not even exist and they have to 
%     implemented by inhouse developers and thus more costs are incurred upfront 
%     and also in the upkeep of the system. In addition to being more costly own 
%     development has higher risks involved.
% \end{sloppypar}
\begin{sloppypar}
    MSA has higher complexity due to more tools needed and having more 
    potentially exposed attack surface. Security can be though of as being as 
    good as its weakest link. In general, a MSA deployment has multiple layers 
    which all have to be consistent and correct. One example is the 
    configuration of the operating system on the server running the 
    virtualization environment. All of the layers from the server hardware to 
    the handling of errors in the actual code have to be of ample quality to 
    mitigate a failure in security.
\end{sloppypar}
\begin{sloppypar}
    The communication that was in monolith a simple in-process call might not be 
    possible as such in a MSA web service. The individual services communicate 
    via the network with high overhead in comparison to a simple function call. 
    Furthermore, the identity and authorization of the entity requesting an action 
    or data can usually be trusted in an in-process call. The mechanisms to 
    allow for proper authentication and authorization amount to even higher 
    overhead for the MSA. There exists a very real risk for the development 
    team to implement an insufficient security scheme.
\end{sloppypar}
\begin{sloppypar}
    In MSA the security should be implemented in depth. There must be a healthy 
    mistrust on all requests and security should be built in to the system.
\end{sloppypar}
\begin{sloppypar}
    Security has to be taken into account right from the beginning of the 
    project in which the architecture is to be changed. The choices made in the 
    development of the web service when following a MA do not carry to the MSA 
    as such.
\end{sloppypar}
\begin{sloppypar}
    Future research\dots
\end{sloppypar}
\begin{sloppypar}
    The research carried out\dots
\end{sloppypar}
% Loppuluku päättää työn. Luvun nimi on tyypillisesti ``yhteenveto'' tai
% ``johtopäätöksiä''. Valitse se otsikko, joka tuntuu sopivammalta työsi
% luonteeseen. Joka tapauksessa loppuluku sisältää niin työn yhteenvedon
% kuin johtopäätöksiä työn tulosten perusteella. Pääajatus on antaa
% lukijalle selvä kuva siitä, miten johdannossa asetettuihin
% tavoitteisiin työssä vastattiin.

% Käsittele loppupuvussa seuraavia asioita (jotakuinkin tässä järjestyksessä):
% %
% \begin{itemize}
%   \item Muistutus työn tavoitteista (sidoksisuus johdantoon)
%   \item Päätulokset kootaan yhteen, pohditaan niiden merkitystä
%   \item Suositukset konkreettisiksi toimenpiteiksi (``Mitä sitten?'' 
% Nyt kun käytössä on tämän työn myötä tullut tieto, 
% mitä se nyt tarkoittaa tälle asialle/alalle.)
%   \item Tulosten soveltuvuus, käyttöön liittyvät rajoitukset
%   \item Jatkotutkimustarve 
% (``Tulevaisuudessa olisi mielenkiintoista selvittää...'' tms.)
%   \item Työn onnistumisen arviointi 
% (Huom! Älä arvioi omaa kirjoitusprosessiasi vaan tekemääsi tutkimusta)
% \end{itemize}

% --------------------------------------------------------------------

